# Учет финансов (FinanceTracker)

Проект представляет собой консольное приложение для учета личных финансов. Оно позволяет управлять счетами, категориями и операциями (доходами и расходами), а также предоставляет функциональность для анализа и экспорта/импорта данных.

## Основные функции

1. **Управление счетами**:
   - Создание, редактирование и удаление счетов.
   - Просмотр текущего баланса.

2. **Управление категориями**:
   - Создание, редактирование и удаление категорий доходов и расходов.
   - Получение списка всех категорий.

3. **Управление операциями**:
   - Добавление, редактирование и удаление операций (доходов и расходов).
   - Получение списка всех операций.

4. **Аналитика**:
   - Подсчет разницы доходов и расходов за выбранный период.

5. **Импорт и экспорт данных**:
   - Экспорт данных в форматы CSV/JSON/YAML.
   - Импорт данных из CSV/JSON/YAML.

6. **Кэширование данных**:
   - Использование прокси для кэширования данных в памяти и их сохранения в файлы.

Для пользователя представлено меню, в котором можно опробовать функционал создания/удаления/редактирования (редактирование только для банка, кажется, этого хватает, чтобы показать функционал редактирования) и импорт/экспорт.

## Используемые паттерны проектирования

### 1. **Фасад (Facade)**

Фасады используются для упрощения взаимодействия с основными модулями приложения. Они предоставляют простой и понятный интерфейс для работы с сервисами, скрывая сложность их внутренней реализации. В проекте реализованы следующие фасады:

1. **`BankAccountFacade`**:
   - Предоставляет методы для управления счетами:
     - Создание счета (`CreateAccount`, `CreateAccountWithId`).
     - Пополнение счета (`Deposit`).
     - Снятие средств (`Withdraw`).
     - Удаление счета (`DeleteAccount`).
     - Получение списка всех счетов (`GetAllAccounts`).
Аналогично прописаны и эти фасады, каждый помогает упаковать методы в одном месте:
2. **`CategoryFacade`**
3. **`OperationFacade`**
4. **`AnalyticsFacade`**

### 2. **Прокси (Proxy)**
   - Прокси используются для кэширования данных в памяти и их сохранения в файлы:
     - `BankAccountProxy` кэширует данные о счетах.
     - `CategoryProxy` кэширует данные о категориях.
     - `OperationProxy` кэширует данные об операциях.
   - Прокси также обеспечивают сохранение данных в файлы JSON при каждом изменении (некая БД).

### 3-4. Команды + декоратор
Паттерн **Команда** используется для инкапсуляции пользовательских сценариев в виде объектов. Каждая команда реализует интерфейс `ICommand`, который содержит метод `Execute()`. Это позволяет легко добавлять новые сценарии и управлять ими.

В проекте реализованы следующие команды:
1. **`ImportBankAccountsCommand`**:
   - Импортирует счета из файла.
2. **`ListAccountsCommand`**:
   - Выводит список всех счетов.
3. **`ListCategoriesCommand`**:
   - Выводит список всех категорий.
4. **`ListOperationsCommand`**:
   - Выводит список всех операций.
5. **`WithdrawCommand`**:
   - Снимает средства со счета.
...и другие, все они находятся в папке **`Commands`**

Паттерн **Декоратор** используется для добавления дополнительной функциональности к командам без изменения их исходного кода. В проекте реализован декоратор `TimingCommandDecorator`, который измеряет время выполнения команды.

- **`TimingCommandDecorator`**:
  - Оборачивает любую команду и измеряет время её выполнения.

### 5. Шаблонный метод

Паттерн **Шаблонный метод** используется для импорта данных из файлов различных форматов (CSV, JSON, YAML). Основная идея заключается в том, что общий алгоритм импорта (чтение файла и парсинг данных) разделен на два этапа:
1. **Чтение файла** (общий для всех форматов).
2. **Парсинг данных** (реализуется по-разному для каждого формата).

#### **Реализация в проекте**

1. **Базовый класс `DataImporter`**:
   - Определяет общий алгоритм импорта:
     ```csharp
     public List<BankAccount> ImportBankAccounts(string filePath)
     {
         var data = ReadFile(filePath); // Чтение файла
         return ParseBankAccounts(data); // Парсинг данных
     }
     ```
   - Абстрактные методы:
     - `ReadFile(string filePath)` — чтение файла.
     - `ParseBankAccounts(string data)` — парсинг данных.

2. **Конкретные реализации**:
   - **`CsvImporter`**:
     - Парсит данные из CSV-файла.
   - **`JsonImporter`**:
     - Парсит данные из JSON-файла.
   - **`YamlImporter`**:
     - Парсит данные из YAML-файла.

### 6. Посетитель

Паттерн **Посетитель** используется для выгрузки данных в файлы различных форматов (CSV, JSON, YAML). Основная идея заключается в том, что каждый тип данных (счет, категория, операция) может быть обработан отдельным методом, что позволяет гибко добавлять новые форматы экспорта.

#### **Реализация в проекте**

1. **Интерфейс `IExportVisitor`**:
   - Определяет методы для обработки каждого типа данных:
     ```csharp
     void Visit(BankAccount account);
     void Visit(Category category);
     void Visit(Operation operation);
     void CompleteExport(); // Метод для завершения экспорта
     ```

2. **Конкретные реализации**:
   - **`CsvExporter`**:
     - Экспортирует данные в CSV-формат.
   - **`JsonExporter`**:
     - Экспортирует данные в JSON-формат.
   - **`YamlExporter`**:
     - Экспортирует данные в YAML-формат.


3. **Использование**:
   - Каждый экспортер реализует методы `Visit` для обработки данных и `CompleteExport` для завершения экспорта.

## Реализованные принципы SOLID и GRASP

### SOLID
1. **Single Responsibility Principle (SRP)**:
   - Каждый класс отвечает за одну задачу:
     - `BankAccountService`, `CategoryService`, `OperationService` отвечают за бизнес-логику.
     - Прокси (`BankAccountProxy`, `CategoryProxy`, `OperationProxy`) отвечают за кэширование и сохранение данных.

2. **Open/Closed Principle (OCP)**:
   - Классы открыты для расширения (например, можно добавить новые методы в сервисы) и закрыты для модификации.

3. **Liskov Substitution Principle (LSP)**:
   - Прокси могут быть использованы вместо реальных сервисов без изменения клиентского кода.

4. **Interface Segregation Principle (ISP)**:
   - Интерфейсы разделены на мелкие и специфичные (`IBankAccountService`, `ICategoryService`, `IOperationService`).

5. **Dependency Inversion Principle (DIP)**:
   - Зависимости строятся на абстракциях (интерфейсах), а не на конкретных реализациях.

### GRASP
1. **High Cohesion**:
   - Классы имеют четко определенные обязанности. Например, `BankAccountService` отвечает только за управление счетами.

2. **Low Coupling**:
   - Классы слабо связаны между собой благодаря использованию интерфейсов и прокси.
     - `IBankAccountService` для работы со счетами.
     - `ICategoryService` для работы с категориями.
     - `IOperationService` для работы с операциями.
   - Это позволяет легко заменять реализации сервисов и соблюдать принцип **Low Coupling**.

## Инструкция по запуску

1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/your-username/FinanceTracker.git
   cd FinanceTracker

Далее можно запустить в VS через консоль там или 
```bash
dotnet build
dotnet run --project FinanceTracker.Presentation
